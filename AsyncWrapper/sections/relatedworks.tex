The work of Liao et al.~\ref{ilc} is the closest to our own
It proposes a new process calculus called ILC and a concrete implementation of the UC framework.
The type system it introduces ensures that correctly types programs can be represented as ITMs.


The EasyUC approach uses the existing EasyCrypt toolset to implement model UC protocols and mechanize the generate of UC-security proofs and proofs of secure composition.
This work aim considerably higher than our work in actually attempting to generate proofs for their protocols. 
However, this work falls short in being able to capture any notion of resource bound computation whereas we are able to make guarnatees about polynomial bounds on our system of ITMs and even guarantee termination of programs through our realization of the import mechanism.
The EasyUC work accepts that not even infinite loops of communication can be caught and, therefore, termination of protocols can't be guarnateed either whereas the import mechanism in Nomos ensures that such infinite loops can not stall protocol progress.

Another work similar to our own is the Symbolic UC by B\"{o}hl and Unruh.
This works uses an applied $\pi$-calculus to symbolically model UC protocols and analyze them.
Similar to the EasyUC work, the goals of this work are somewhat orthogonal to the our own goals.
However, Symbolic UC does attempt to create an implementatio of UC using the $\pi$-calculus however neglects to address any issues of polynomial runtime.

Perhaps the closes work to our own is that of Liao et al.~\cite{ilc} that builds an executable version of the UC framework by introducing a new process calculus called ILC.
ILC introduces a type system that guarantees that ILC programs (i.e. functionalities, protocols, etc) can be expressed as ITMs as in the UC framework.
However, one drawback of ILC is that it's notion of polynomial time ends up being too restrictive.
In ILC only closed terms without any unbonded variables, i.e. and entire UC exection of a system of ITMs, can be shown to be polynomial in their definition of polynomial time.
Proving polynomial time for open terms, such as a protocol $\pi$, requires reasoning over all possible contexts in which the protocol could exist however such a definition of polynomial time becomes too restrictive where even a simple ping-responde server protocol wouldn't be considered polynomial time.
