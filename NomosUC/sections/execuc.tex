In this section we introduce the UC experiment in Nomos and the resulting emulation definition.
We continue on to state the dummy lemma theorem as well as the composition theorem for Nomos UC.

For the remainder of this section when we refer to a protocol we refer to a pair of machines as in Definition~\ref{def:protocol}.

\begin{definition}\label{def:protocol}
A \textit{protocol} $\pi$ is a pair of terms ($\mathcal{P}(e)$, $\mathcal{F}$) where $\mathcal{P}$ is a wrapper around protocol code, $e$ is the program for a single party, and $\mathcal{F}$ is an ideal functionality.
\end{definition}
 
Protocols with no ideal functionality can default to an empty ideal functionalty that immediately returns the write-token to the Environment.

\subsection{The UC Experiment}
The \msf{ExecUC} function creates an execution of the UC experiment that spawns the input environments and all of the other necessary machines: a protocol wrapper, the functionality, and the adverasry.
Figure~\ref{fig:execuc} illustrates the function in Nomos.

\begin{figure*}
\begin{lstlisting}[basicstyle=\small\ttfamily]
proc execUC : (k: int), (rng: [Bit]) |- ($d : bit) = 
{
    $z <- PS.env[PS.z2p][PS.p2z][PS.z2a][PS.a2z] <- k r ;
    sid = recv $z ;
    clist = recv $z ;
    ...
    #pw_to_f <- communicator_init[PS.p2f]{PS.p2fn} <- pw_id f_id ;
	#f_to_pw <- communicator_init[PS.f2p]{PS.f2pn} <- f_id pw_id ;
	...
	send $z #pw_to_z ;
	send $z #z_to_pw ;
	$pw <- protocol_wrapper[PS.p2z][PS.z2p][PS.p2f][PS.f2p][PS.p2a][PS.a2p] <-
	k rng clist #pw_to_f #f_to_pw #pw_to_a #a_to_pw #pw_to_z #z_to_pw ;
	...
    $z.start ;
    $d <- $z ;
}
\end{lstlisting}
\caption{The \msf{execUC} function spawns all the necessary ITMs in the UC execution: the environment, the protocol wrapper, the functionality, and the adversary. Each is parameterized with a security parameter $k$ and a uniformly random bit string $r \in \{0,1\}^{poly(k)}$. Eventually, the environment is initiated and it returns a bit $b$ which is its guess for which world it is in.}
\label{lst:execuc}
\end{figure*}
We elide over some sections of code in \msf{execUC} in Figure~\ref{lst:execuc}.
Mainly we exclude spawning all of the communicators for each pair of channel between all the ITMs, and we exclude spawning the other ITMs, namely the functionality and the adverasary as they are very similar to the \msf{protocolWrapper}.
The full code of the \msf{execUC} can is shown in appendix Figure~\ref{app:lst:execuc}.

Instead of accepting as input the initial process definition for each of the spawned machines, Nomos UC assumes the existence of a user module \msf{PS} which defines the environment, \msf{PS.z}, the functionality, \msf{PS.F\_code}, and the adverasry \msf{PS.adv}.
The reason for this is that the current implementation of Nomos does not allow it.
Theoretically, such a construction is possible~\cite{pfenning} and this is why all of our pseudo-code describes \msf{execUC} as accepting process definitions for the various user-defined programs as parameters.

The environment is the first to be spawned and selects an \msf{sid} and a list of pids of corrupt parties, \msf{clist}.
Once the \msf{sid} is selected, all the communicators used between the machines are create and the processes spawned.
They are parameterized with the id's of the endpoints, the type of the messages \msf{PS.p2f}, and the potential sent over them \msf{PS.f2p}.
Finally, \msf{execUC} activates \Environment~ with a \msf{start} message and returns a bit from \Environment~ indicating a guess as to which world this is.

The only generic process spawned is the \msf{partyWrapper}.
An environment may spawn any number of parties throughout its execution.
Therefore, the \msf{partyWrapper} handle incoming message to protocol parties and spawns new processes for them on the fly.
For existing parties, it intercepts incoming messages and routes them to the right party, and it intercepts outgoing messages and appends the ID of the writing party to them. 

\todo{ Not sure if this is relevant, wait for better understanding from ankush/andrew. The total potential in the system is inferred by the Nomos type-system, and given to the first spawned process: \msf{execUC}.
Therefore, well-typed programs are only those where the potential type parameters provide enough import for an execution.}

\paragraph{Spawning Parties On-Demand}
One feature of the UC framework that is not readily captured in code is spawning parties on-demand.
When the environment writes to a protocol party for the first time, a new ITM is spawned that is an instance of the protocol code.
The code, dubbed the \msf{protocolWrapper} in the code above, handles such behvaior and encapsulates all of the protocol parties.

When protocol wrapper maintains a list of the parties that exist by their \msf{pid} and routes incoming messages directed at them, to them.
\todo{The dictionary for storing and sending is not precise yet.}
If the party doesn't exist, the partywrapper spawns communicators for the new party and spawns an instace of the user specified code.
It then spawns a new process translate for each of the outgoing communicators from the new party:

\begin{lstlisting}
<- translate <- p $toF $pw_to_f ;
\end{lstlisting}

The transalte process shown in Figure~\ref{lst:translate}

\begin{figure}
\begin{lstlisting}[basicstyle=\small\ttfamily]
proc translate[a]{an} :
  (id: pid), (#to_inner: comm[a]{an}), 
  (#to_outer: comm[pid ^ b]{an}) |- ($t: 1) =
{
  $ti <- acquire #to_inner ;
  case $ti (
    yes => msg = recv $ti ;
           get {an} $ti ;
           send $to id ^ msg ;
           pay $to {an} ;
           $t <- translate id #to_inner #to_outter ;
  | no => $t <- translate id #to_inner #to_outter ;
}
\end{lstlisting}
\caption{The translate function appends the ID of the sending party to all outgoing messages. The protocol code itself assumes it's writing to another ITM and does not need to both with it's own ID.}
\label{lst:translate}
\end{figure}

\subsection{Polynomial Bound}
The UC import mechanism provides a way to define polynomial time computation and resource-bounds by ensuring that a single ITM's execution is upper-bounded by some value $T(n)$ where $T$ is a polynomial and $n$ the total units of import the ITM ever receives.
This is enough to reaosn about polynomial-time, however when reasoning about security we care specifically of ITMs that whose computation is bounded by some poynomial in the security parameter $k$. 
In Nomos, we take advantage of the import built into the type system to ensure ITMs in Nomos are PPT in the security parameter. 

\begin{definition}[PPT Term]\label{def:pptterm}
A \textit{PPT term} is a \textit{well-typed} term $e(k, r)$ that is \textit{closed} except for security parameter $k$, random bit sequence $r$.
\end{definition}

We first-define terms that are well-typed in the traditional session-types-sense in Definition~\ref{def:pptterm}, i.e. without any resource constraints~\cite{sessiontypes}.
Such terms are closed except for the security parameter $k$ and some uniformly random bit sequence $r$. 
For the remainder of the the discussion on polynomial we are concerned with constraining terms that are \textit{well-typed} for regular session types to be well-resource-typed as well.
Specifically we would like to reason about terms in NomosUC being PPT in the security parameter $k$: the standard notion of resource constraits in UC security.

\begin{theorem}[PPT in $k$]\label{thm:ppt}
A \textit{PPT Term} $e(k, r)$ is well-resource-typed if, given a polynomial $T$, $\exists n(k) \in poly(k)$ amount of import s.t. $\forall k, r, e(k, r) {n(k)}$ is terminates in at most $T(n)$ steps.
\end{theorem}

\begin{proof}
The Nomos type system guarntees ITM $e$ is upper-bounded by $T(n) \in poly(k)$ units of potential. 
Therefore, regardless of the probabilistic state transitions that ITM makes according to $r$, $e$ is guaranteed to be upper-bounded by $pol(k)$ satisfying the definition of probabilistic polynomial time in $k$.
\end{proof}

In UC we care about emulation between systems of ITMs when reasoning about protocol security. 
Therefore, we must define the notion of PPT at the ITM sytem level as well.
First we define the \msf{execUC} function parameterized by a security parameter $k$ and a sequence of random bits $r$.
Additionally, it has implicit parameters: protocol $\pi$, an adversary $\Adversary$, and an environment $\Environment$ that are referenned through a user-defined module \msf{PS}.
The system of ITMs $\msf{execUC}(\pi, \Adversary, \Environment)$ is a closed term except for security parameter $k$, random bit sequence $r$, initial import $n$, and a function $T$.
Thus, \msf{execUC} is a \textit{PPT term} and, by Theorem~\ref{thm:ppt} it is PPT in $k$ if $n \in poly(k)$.


\subsection{Emulation}
A proof of security in the UC framework relies upon emulation.
In general, we say that a protocol $\pi$ exhibits some desired security properties if no environment providing inputs to protocol parties (and the adversary) can distinguish between the $\pi$ and another pprotocol $\phi$ that possesses the desired properties.
In most cases we compare a real protocol $\pi$ with an idealized protocol $\phi$ which encapsulated by a single ideal functionality $\F$.
The ideal functionality is a trusted third party that executes the entire protocol on behalf of all of the participants.
Therefore, it is much simpler than a real protocol where mutually distrustful parties communicate with each other, and its security properties are easily proven.

It is clear from Figure~\ref{lst:execuc} that its output is a distribution induced by the random bit string $r$ (note that without any randonmess \msf{execUC} is entirely deterministic for any environment).
When we reason about emulation between two protocols what we really means is the indistinguishability between the ensembles that represent the outputs of \msf{execUC}.
We define indistinguishabiliy between ensembles in a standard way using \textit{statistical distance} in Definition~\ref{def:distance}.

\begin{definition}[Indisinguishability]\label{def:distance}
Two ensembles $\mathcal{D}_{1,k}, \mathcal{D}_{2,k}$ are indistinguishable, $\mathcal{D}_{1,k} \approx \mathcal{D}_{2,k}$, if their statistical distance is at most $negl(k), \forall k$.
\end{definition}

Indisintiguishability between two protocols is defined as follows:
\begin{definition}[Emulation]\label{def:emulation}
protocol $\pi = (\pi, \F_1)$ emulates another protocols $\phi = (\phi, \F_2)$ if for adversary \Adversary~, $\exists$ simulator $\mathcal{S} \forall \Environment, \forall k, \forall r \in \{0,1\}^{poly(k)}$ s.t. $\msf{execUC}(\pi, \Environment, \Adversary) \approx \msf{execUC}(\phi, \Environment, \Simulator)$. All of $\pi, \phi, \Environment, \Adversary, \Simulator$ are assumed to be \textit{well--resource-typed PPT terms}.
\end{definition}


Further, we care about emulation with respect to an ideal protocol $\phi$ which is really just a an ideal functionality. 
We say the protocol $\pi$ UC-realizes an ideal functionality $\F$ if Definition~\ref{def:emulation} holds for $\phi = (\phi_{\mathcal{D}}, \F)$, where $\phi_{\mathcal{D}}$ is the dummy protocol that forwards all inputs to $\F$.

\begin{definition}[UC-Realize]
If UC-emulation (Definition~\ref{def:emulation}) holds for an ideal-world protocol $(\phi, \F_1)$ and real-world protocol $(\pi, \F_2)$ we say that the protocol $(\pi, \F_2)$ \textit{UC-realizes} $\F_1$
$$ (\pi, \F_2) \approx \F_1 $$
in the $\F_2$-hybrid world.
\end{definition}

\paragraph{Dummy Lemma}
In Definition~\ref{def:emulation} we characterize emulation by a simulator \Simulator, for a specific adversary \Adversary.
However, there is a more useful definition of emulation where proving emulation w.r.t. a single adversary, namely the dummy adverasry \DummyAdv, is sufficient to guarantee emulatioon w.r.t any other adversary.

\begin{theorem}[Dummy Lemma]\label{thm:dummy}
For protocols $\pi$ and $\phi$, $\msf{execUC}(\pi, \Environment, \DummyAdv) \approx \msf{execUC}(\phi, \Environment, \Simulator_{\mathcal{D}}) \forall \Environment \Rightarrow \exists$ \textit{well-resource-typed, PPT} $\Simulator_{\mathcal{D}}$ s.t. $\msf{execUC}(\pi, \Environment, \Adversary') \approx \msf{execUC}(\phi, \Environment, \Simulator')$ for any other \textit{well-resource-typed} $\Adversary'$.
\end{theorem}

Theorem~\ref{thm:dummy} can be broken up into smaller parts to prove individually.

\begin{lemma}[PPT \Simulator]\label{lem:dummyppt}
For every well-resource-typed real-world \Adversary and a well-resource-typed dummy simulator $\Simulator_{\mathcal{D}}$ the constructed \Simulator~ is well-resource-typed $\forall \Environment$ that are well-typed for adverasry \Adversary (i.e. in the real-world).
\end{lemma}

\begin{proof}
The constructed \Simulator~ internally simulates the real-world adversary \Adversary~ and the dummy simulator \Dummysim~ with some constant over-head in activation. 
The internal simulation is given virtual import through the \msf{simpay} and \msf{simulate} calls which ensures that the simulated process uses the potential available to \Simulator.
Therefore, if \Adversary~ and \Simulator~ are well-resource-typed (i.e. they are PPT in $k$ in the sense of Theorem~\ref{thm:ppt}) then a polynomial
$$ T(n) = T_{\Adversary}(n) + T_{\Dummysim}(n) + O(n) $$
where $T$ is the maximum of the two polynomials bounding \Adversary~ and \Dummysim and $n$ is the total import received by \Simulator. 
Therfore, we conclude that \Simulator~ satisfies our definition of PPT in $k$ and is, therefore, well-resource-typed.
\end{proof}

\begin{proof}
We give a full construction of the simulator \Simulator~ in the Appendix.
The simulator proceeds identically to the simulator in the original UC proof. It performs a constant amount of work as overhead of routing messages between the internall simulated \Adversary~ and the dummy simulator $\Simulator_{\mathcal{D}}$. 
Therefore, the bounding polynomial for \Simulator~ can be determined to be:
$$ T(n) = T_{\Adversary}(n) + T_{\Simulator_{\mathcal{D}}} + O(n)$$ 
whhere $n$ is the total import received by \Simulator.
\end{proof}

	

%%
%Notes
%%

% It should be okay that we have one global T because processes can't depend on the type T,n basically. 
% We can just have T as part of the type and then we should be good to go.
% Composition theorem  


%\begin{definition}
%For any term $e$ that is \textit{well-typed}, $\exists n \in \mathbb{N}$ and a poynomial $T$ s.t. $e$ halts in $\leq T(n) steps$.
%
%Given some potential T(n) where n in poly(k) 
%
%Poised state a configuration of processes ==> saying that it has terminated to a value. For any configuration $e$ within $T(n)$ step it will reach a poised state.
%Every exeution step it takes its potential goes down and the sum of that is always a constant. 
%In the end the potential will be non-negative <= T(n).
%
%only closed and only well-typed
%security parameter has to be present
%
%1. givne polynomial import 
%
%2. dependent on some paramter $k$ then it is still PPT then it is well-typed
%
%3. random strings: it's necessar to just talk about distributions associated with closed terms
%
%\end{definition}
%
%\begin{definition}
%For all $k \in \mathbb{N}$ and $r \in \{0,1\}^{poly(k)}$ the term $\msf{execUC}_{k,r,n,T}(\Environment, \phi, \F, \Adversary)$ is \textit{well-typed} if $\exists n, T$ s.t. $\msf{execUC}_{k,r,n,T}$ executes in $\leq T(n)$ steps.
%\end{definition}
%
%\begin{definition}\label{def:emulation}
%Given well-typed protocols $\pi = (\mathcal{P}(\pi_1), \mathcal{F}_1)$, $\phi = (\mathcal{P}(\phi_2), \mathcal{F}_2)$, adversary $\mathcal{A}$, and simulator $\mathcal{S}$, $\pi$ and $\phi$ securely emulate each other if for all environments $\mathcal{Z}$, security parameters $k$ $\msf{execUC}_{k,r,n,T} (\mathcal{Z}, \phi_2, \mathcal{F}_2, \mathcal{S})$ and  $\msf{execUC}_{k,r} (\mathcal{Z}, \pi_1, \mathcal{F}_1, \mathcal{A})$ are \textit{well-typed}  and $\msf{execUC}_k (\mathcal{Z}, \phi_2, \mathcal{F}_2, \mathcal{S}) \approx \msf{execUC}_k (\mathcal{Z}, \pi_1, \mathcal{F}_1, \mathcal{A})$.
%\end{definition}
%
%\begin{theorem}
%If there exists a well-typed \msf{PPT} simulator $\mathcal{S}_d$ as in Definition~\ref{def:emulation} such that $\forall \mathcal{Z}, \msf{execUC}_{k,r,n,T}(\mathcal{Z}, \phi, \F_2, \mathcal{S}_d) \approx \msf{execUC}_{k,r,n,T}(\mathcal{Z}, \pi, \F_1, \mathcal{A}_d)$, where $\mathcal{A}_d$ is the dummy adversary, $\Rightarrow \exists \mathcal{S}$ s.t. $\msf{execUC}_{k,r}(\mathcal{Z}, \phi, \F_2, \mathcal{S}) \approx \msf{execUC}_{k,r}(\mathcal{Z}, \pi, \F_1, \mathcal{A}$ for any well-typed PPT $\mathcal{A}$.
%
%swap the quanitifers for any A there exists an S
%all Z needs to be present for all of them.
%
%\end{theorem}
%
%\begin{figure}
%
%\end{figure}
