There are many works that attempt to formalize the UC framework with an implementation for protocol analysis and proof generation.

One of the most relevant works to our own is EasyUC~\cite{easyuc}. 
EasyUC uses the existing EasyCrypy~\cite{easycrypt} toolset to model UC protocols and mechanize proof generation. 
It departs from EasyCrypt's limtations to game-based security definitions (lacking simulation-based composition).
However, it still lacks a notion of polynomial time. The authors, themselves, mentions that it can't detect deviant behavior like the adversary and functionality passing messages between each other indefinitely. 
Our use of the import mechainsm and session types let us reason about polynomial time in the sytem of ITMs encompassed by \msf{execUC} but also locally for \textit{open} terms. 
Furthermore, import in NomosUC lets us have guarantees of termination as well by the polyomial import constraints added to UC by Canetti et al.

Liao et al. introduce executable UC through a new process calculus called ILC~\ref{ilc}.
This work adds some notion of polynomial time although it proves to be too restrictive. 
It results from the fact that poly-time can only be reasoned about for \textit{closed} terms like a full UC execution.
In order to reason about polynomial time for a particular protocol $\pi$ we must reason over all possible other terms that connect to $\pi$ and require that it is polynomial in all such cases.
A simple ping-response server can not be proven to by poly-time in this definition for a deviant other ITM that connects to $\pi$. 
In Nomos, however, as mentioned above, open terms are limited to polytime regardless of the connected other terms because of the import mechanism and the NomosUC type system that guarantees termination. 

Other works that rely in symbolic modelling of cryptography, for example, SymbolicUC~\cite{symbolicuc}, are subsumed by the above ILC work and similarly lack any polynomial time notion. 
\todo{Say something about $\pi$-calculus with probabilistic polynomial time extensions}.


To the best of our knowledge, this is the first work to deal with the new import notion of polynomial time introduced to the UC framework in 2018.
A few other works refer to the import mechanism, but it is restricted to simply defining the import a protocol is given.
	
%easyUC:
%* can not dynamially create new instances of parties/functionalities must statically determine the number of functionalities/parties spawned
%* 
%
%
%The work of Liao et al.~\ref{ilc} is the closest to our own
%It proposes a new process calculus called ILC and a concrete implementation of the UC framework.
%The type system it introduces ensures that correctly types programs can be represented as ITMs.
%However, one drawback of the ILC work is that its polynomial time representation 
%
%
%The EasyUC approach uses the existing EasyCrypt toolset to implement model UC protocols and mechanize the generate of UC-security proofs and proofs of secure composition.
%This work aim considerably higher than our work in actually attempting to generate proofs for their protocols. 
%However, this work falls short in being able to capture any notion of resource bound computation whereas we are able to make guarnatees about polynomial bounds on our system of ITMs and even guarantee termination of programs through our realization of the import mechanism.
%The EasyUC work accepts that not even infinite loops of communication can be caught and, therefore, termination of protocols can't be guarnateed either whereas the import mechanism in Nomos ensures that such infinite loops can not stall protocol progress.

%Another work similar to our own is the Symbolic UC by B\"{o}hl and Unruh.
%This works uses an applied $\pi$-calculus to symbolically model UC protocols and analyze them.
%Similar to the EasyUC work, the goals of this work are somewhat orthogonal to the our own goals.
%However, Symbolic UC does attempt to create an implementatio of UC using the $\pi$-calculus however neglects to address any issues of polynomial runtime.
%
%Perhaps the closes work to our own is that of Liao et al.~\cite{ilc} that builds an executable version of the UC framework by introducing a new process calculus called ILC.
%ILC introduces a type system that guarantees that ILC programs (i.e. functionalities, protocols, etc) can be expressed as ITMs as in the UC framework.
%However, one drawback of ILC is that it's notion of polynomial time ends up being too restrictive.
%In ILC only closed terms without any unbonded variables, i.e. and entire UC exection of a system of ITMs, can be shown to be polynomial in their definition of polynomial time.
%Proving polynomial time for open terms, such as a protocol $\pi$, requires reasoning over all possible contexts in which the protocol could exist however such a definition of polynomial time becomes too restrictive where even a simple ping-responde server protocol wouldn't be considered polynomial time.
